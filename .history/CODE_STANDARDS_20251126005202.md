# AI ORCHESTRATOR - CODE STANDARDS & BEST PRACTICES

## ðŸŽ¯ CORE PRINCIPLES

### 1. COMPUTE EFFICIENCY - SAVE WHERE POSSIBLE
**Mandate**: Every line of code must justify its computational cost.

#### Optimization Priorities
1. **Use Existing Tools First**
   - Leverage linters (pylint, flake8, mypy, black)
   - Use built-in libraries before external dependencies
   - Utilize VS Code extensions and language servers
   - Employ existing frameworks and patterns

2. **Avoid Redundant Computation**
   - Cache expensive operations
   - Memoize pure functions
   - Reuse computed results
   - Lazy load when possible

3. **Efficient Data Structures**
   - Choose appropriate data structures (dict vs list vs set)
   - Use generators for large datasets
   - Stream data instead of loading all at once
   - Implement pagination for large results

4. **Resource Management**
   - Close file handles and connections
   - Use context managers (`with` statements)
   - Clean up temporary resources
   - Monitor memory usage

---

## ðŸ“‹ CODE QUALITY STANDARDS

### HIGHEST Standards Enforced

#### Level 1: Syntax & Style (AUTOMATED)
**Tools**: black, isort, autopep8
**Enforcement**: Pre-commit hooks, CI/CD

```python
# âœ… CORRECT: Black formatted, sorted imports
from typing import Dict, List, Optional

import anthropic
import chromadb
from pydantic import BaseModel

from src.core.config import Config
from src.memory.base import MemoryTier


class Agent(BaseModel):
    """Agent with proper formatting."""
    
    name: str
    role: str
    model: str
```

```python
# âŒ WRONG: Poor formatting, unsorted imports
from src.core.config import Config
import anthropic
from typing import Dict,List
import chromadb

class Agent(BaseModel):
  name:str
  role:str
```

---

#### Level 2: Type Safety (ENFORCED)
**Tools**: mypy (strict mode)
**Enforcement**: CI/CD, pre-commit

```python
# âœ… CORRECT: Full type hints
from typing import Dict, List, Optional, Union
from pathlib import Path


def process_task(
    task_id: str,
    config: Dict[str, Any],
    timeout: Optional[int] = None
) -> Dict[str, Union[str, int, bool]]:
    """
    Process a task with full type safety.
    
    Args:
        task_id: Unique task identifier
        config: Configuration dictionary
        timeout: Optional timeout in seconds
        
    Returns:
        Dictionary with task results
        
    Raises:
        ValueError: If task_id is invalid
        TimeoutError: If task exceeds timeout
    """
    result: Dict[str, Union[str, int, bool]] = {
        "task_id": task_id,
        "status": "completed",
        "duration": 42
    }
    return result
```

```python
# âŒ WRONG: No type hints
def process_task(task_id, config, timeout=None):
    result = {"task_id": task_id, "status": "completed"}
    return result
```

---

#### Level 3: Documentation (MANDATORY)
**Tools**: pydocstyle, interrogate
**Enforcement**: CI/CD, coverage checks

```python
# âœ… CORRECT: Comprehensive documentation
from typing import List, Optional


class TaskQueue:
    """
    Priority-based task queue with dependency tracking.
    
    This queue manages tasks with priorities, dependencies, and
    automatic scheduling. It ensures tasks are executed in the
    correct order while respecting resource constraints.
    
    Attributes:
        max_size: Maximum number of tasks in queue
        priority_levels: Number of priority levels (1-5)
        
    Example:
        >>> queue = TaskQueue(max_size=1000)
        >>> queue.add_task("task1", priority=1)
        >>> task = queue.get_next_task()
        >>> print(task.id)
        'task1'
    """
    
    def __init__(self, max_size: int = 1000, priority_levels: int = 5) -> None:
        """
        Initialize the task queue.
        
        Args:
            max_size: Maximum queue size (default: 1000)
            priority_levels: Number of priority levels (default: 5)
            
        Raises:
            ValueError: If max_size < 1 or priority_levels < 1
        """
        if max_size < 1:
            raise ValueError("max_size must be at least 1")
        if priority_levels < 1:
            raise ValueError("priority_levels must be at least 1")
            
        self.max_size = max_size
        self.priority_levels = priority_levels
        self._queue: List[Task] = []
    
    def add_task(
        self,
        task_id: str,
        priority: int = 3,
        dependencies: Optional[List[str]] = None
    ) -> None:
        """
        Add a task to the queue.
        
        Args:
            task_id: Unique task identifier
            priority: Task priority (1=highest, 5=lowest)
            dependencies: List of task IDs this task depends on
            
        Raises:
            ValueError: If priority is invalid
            QueueFullError: If queue is at max capacity
        """
        pass
```

```python
# âŒ WRONG: No documentation
class TaskQueue:
    def __init__(self, max_size=1000):
        self.max_size = max_size
        self._queue = []
    
    def add_task(self, task_id, priority=3):
        pass
```

---

#### Level 4: Testing (>80% COVERAGE)
**Tools**: pytest, pytest-cov, pytest-asyncio
**Enforcement**: CI/CD, coverage gates

```python
# âœ… CORRECT: Comprehensive tests
import pytest
from unittest.mock import Mock, patch

from src.agents.prometheus import PrometheusAgent
from src.core.exceptions import TaskDecompositionError


class TestPrometheusAgent:
    """Test suite for Prometheus orchestrator agent."""
    
    @pytest.fixture
    def agent(self):
        """Create a Prometheus agent for testing."""
        config = {"model": "claude-3-opus", "timeout": 300}
        return PrometheusAgent(config)
    
    @pytest.fixture
    def mock_task(self):
        """Create a mock task."""
        return {
            "id": "task_123",
            "description": "Build authentication API",
            "priority": 1
        }
    
    def test_agent_initialization(self, agent):
        """Test agent initializes correctly."""
        assert agent.name == "Prometheus"
        assert agent.role == "Orchestrator"
        assert agent.model == "claude-3-opus"
    
    def test_task_decomposition_success(self, agent, mock_task):
        """Test successful task decomposition."""
        subtasks = agent.decompose_task(mock_task)
        
        assert len(subtasks) > 0
        assert all(isinstance(t, dict) for t in subtasks)
        assert all("id" in t for t in subtasks)
        assert all("dependencies" in t for t in subtasks)
    
    def test_task_decomposition_invalid_task(self, agent):
        """Test decomposition fails with invalid task."""
        with pytest.raises(TaskDecompositionError):
            agent.decompose_task(None)
    
    @pytest.mark.asyncio
    async def test_async_task_execution(self, agent, mock_task):
        """Test asynchronous task execution."""
        result = await agent.execute_async(mock_task)
        
        assert result["status"] == "completed"
        assert "duration" in result
    
    def test_agent_state_management(self, agent):
        """Test agent state is managed correctly."""
        assert agent.state == "idle"
        
        agent.start_task("task_123")
        assert agent.state == "active"
        
        agent.complete_task("task_123")
        assert agent.state == "idle"
    
    @patch('src.integrations.claude_code.ClaudeCodeClient')
    def test_tool_integration(self, mock_claude, agent, mock_task):
        """Test integration with Claude Code tool."""
        mock_claude.return_value.generate.return_value = "code output"
        
        result = agent.use_tool("claude_code", mock_task)
        
        assert result == "code output"
        mock_claude.return_value.generate.assert_called_once()
```

```python
# âŒ WRONG: Minimal or no tests
def test_agent():
    agent = PrometheusAgent({})
    assert agent is not None
```

---

#### Level 5: Error Handling (COMPREHENSIVE)
**Tools**: Custom exceptions, logging
**Enforcement**: Code review, QC validation

```python
# âœ… CORRECT: Comprehensive error handling
from typing import Dict, Any
import logging
from contextlib import contextmanager

from src.core.exceptions import (
    AgentException,
    TaskException,
    TimeoutException,
    ValidationException
)

logger = logging.getLogger(__name__)


class Agent:
    """Base agent with comprehensive error handling."""
    
    def execute_task(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute a task with full error handling.
        
        Args:
            task: Task dictionary
            
        Returns:
            Task result dictionary
            
        Raises:
            ValidationException: If task is invalid
            TimeoutException: If task exceeds timeout
            AgentException: For other agent errors
        """
        # Validate input
        try:
            self._validate_task(task)
        except ValueError as e:
            logger.error(f"Task validation failed: {e}")
            raise ValidationException(f"Invalid task: {e}") from e
        
        # Execute with timeout
        try:
            with self._timeout_context(task.get("timeout", 300)):
                result = self._execute_internal(task)
        except TimeoutError as e:
            logger.error(f"Task {task['id']} timed out")
            raise TimeoutException(
                f"Task {task['id']} exceeded timeout"
            ) from e
        except Exception as e:
            logger.exception(f"Task {task['id']} failed: {e}")
            raise AgentException(
                f"Task execution failed: {e}"
            ) from e
        
        # Validate output
        try:
